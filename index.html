<head>
	<title>All a-board</title>
	<style>
		body { margin: 0; }
		/*canvas { width: 100%; height: 100% }*/
	</style>
</head>
<body>
<button style= "margin:50" onclick=rollDice()>Roll dice</button>
</body>
<script src="three.min.js"></script>

<script src="OrbitControls.js"></script>

<script src="Detector.js"></script>
<script src="stats.min.js"></script>

<script>

	if ( ! Detector.webgl ) 
		Detector.addGetWebGLMessage();

	var container, stats;
	var camera, controls, scene, renderer;

	var tileSize = 20;
	var objects = [];
	var selectedObject;
	var currentIndex = 0,endPoint=0,startPoint=0;
	var cube;

	init();
	render();

	var deltaX, deltaY, deltaRotate,
		startTime, startX, startY, startRotate,
		moving = false;
	var diceValue;
	var transitionTime = 200;

	function animate() {

		requestAnimationFrame(animate);
		controls.update();
		if(moving)
		{
			timeGap = new Date() - startTime;
			fraction = timeGap/transitionTime;
			if (fraction > 1)
			{
				fraction = 1;
				moving = false;
			}
			cube.position.x = startX + deltaX * fraction;
			cube.position.y = startY + deltaY * fraction;
			cube.rotation.z = startRotate + deltaRotate * fraction;
		}
		render();
	}

	
	function moveCoin(diceValue){
			
			startPoint=endPoint;
			currentTile = scene.getObjectByName(startPoint);
			endPoint = startPoint + diceValue;
			nextTile = scene.getObjectByName(endPoint);
			
			startX = currentTile.position.x;
			startY = currentTile.position.y;
			startRotate = currentTile.rotation.z;

			deltaX = nextTile.position.x - startX;
			deltaY = nextTile.position.y - startY;
			deltaRotate = nextTile.rotation.z - startRotate;

			moving = true;
			startTime = new Date();
	}

	function init() {

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
		camera.position.x =  camera.position.y = -7 * tileSize;
		camera.position.z = 200;
		camera.up.set(0,0,1);

		controls = new THREE.OrbitControls( camera );
		controls.damping = 0.2;

		controls.maxPolarAngle = 2*Math.PI/5;

		controls.minAzimuthAngle = -Math.PI/2;
		controls.maxAzimuthAngle = 0;

		controls.addEventListener( 'change', render );

		scene = new THREE.Scene();
	    var axes = new THREE.AxisHelper(200);
	    scene.add(axes);
		scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

		var tile = new THREE.PlaneBufferGeometry (tileSize*0.9, tileSize*0.9, 10, 10);
		var img = new THREE.MeshBasicMaterial({ 
		    map:THREE.ImageUtils.loadTexture('img/woodtile.jpg')
		 });
		img.map.needsUpdate = true;
	    var material = new THREE.MeshPhongMaterial({
		  color: 0xdddddd, 
		  wireframe: true
		});
	    // img.map.needsUpdate = true;

	    // var offset = -tileCount * tileSize/2;
	    var parallelDirection;
	    for(var i=0;i<13;i++)
	    {
	    	var a,b;
		    if(i<6)
		    {
		    	a = i-7;
		    	b = 1;
		    	parallelDirection = 0;
		    }
		    else if(i<12)
		    {
		    	a = -1;
		    	b = i-4;
		    	parallelDirection = -Math.PI/2;
		    }
		    else
		    {
		    	a=0 ;
		    	b=7;
		    	parallelDirection = 0;
		    }

		    //Player1 surround
    		var plane = new THREE.Mesh(tile, material);
		    plane.position.y = (a) * tileSize ;
		    plane.position.x = (b) * tileSize;
		    plane.name = i;
		    plane.userData.next=i+1;
		    plane.rotation.z = parallelDirection;
		    scene.add(plane);
		    objects.push(plane);

		    //Player2 surround
		    var plane = new THREE.Mesh(tile, material);
		    plane.position.y = (b) * tileSize ;
		    plane.position.x = (-a) * tileSize;
		    plane.name = i+13;
		    plane.userData.next=i+14;
		    plane.rotation.z = parallelDirection+Math.PI/2;
		    scene.add(plane);
		    objects.push(plane);

		    //Player3 surround
		    var plane = new THREE.Mesh(tile, material);
		    plane.position.y = (-a) * tileSize ;
		    plane.position.x = (-b) * tileSize;
		    plane.name = i+26;
		    plane.userData.next=i+27;
		    plane.rotation.z = parallelDirection+Math.PI;
		    scene.add(plane);
		    objects.push(plane);

		    var plane = new THREE.Mesh(tile, material);
		    plane.position.y = (-b) * tileSize ;
		    plane.position.x = (a) * tileSize;
		    plane.name = i+39;
		    plane.rotation.z = parallelDirection+3*Math.PI/2;
		    if(i<12)
		    	plane.userData.next=i+40;
		    else
		    {
			    plane.userData.next=0;
		    }
		    scene.add(plane);
		    objects.push(plane);
		}


		firstObject = objects[0];

	    /// dummy object
		var geometry = new THREE.BoxGeometry( 10, 20, 10 );
		var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
		cube = new THREE.Mesh( geometry, material );
		cube.position.copy(objects[0].position)
		cube.position.z = 10;
		cube.name = 'c1'
		scene.add( cube );

		// var diceValue, nextIndex;
		// currentIndex = firstObject.userData.id;
		// diceValue = Math.floor(Math.random() * 6) + 1  ;
		// nextIndex = currentIndex + diceValue;
		// startX = objects[currentIndex].position.x;
		// for(var index=currentIndex; index<=nextIndex; index++)
		// {

		// 	nextPos = scene.getObjectByName('c1').position;
		// 	cube.position.x = nextPos.x;
		// 	cube.position.y = nextPos.y;
		// 	animate();
		// }
		

		

		loader = new THREE.JSONLoader();
		// loader.load('model.json', function(geo, mat){
		// 	console.log(geo,mat);
		// });

		light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( 1, 1, 1 );
		// scene.add( light );

		light = new THREE.DirectionalLight( 0x002288 );
		light.position.set( -1, -1, -1 );
		// scene.add( light );

		light = new THREE.AmbientLight( 0x222222 );
		scene.add( light );

		// renderer

		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setClearColor( scene.fog.color );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );

		document.body.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild( stats.domElement );


		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		window.addEventListener( 'resize', onWindowResize, false );
    	document.addEventListener( 'mousedown', onDocumentMouseDown, false );

		animate();

	}

	function onDocumentMouseDown( event ) 
		{
			event.preventDefault();
			mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
			mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

			raycaster.setFromCamera( mouse, camera );
	        var intersects = raycaster.intersectObjects( objects );
	        // Change color if hit block
	        if ( intersects.length > 0 ) {
	            // intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
	            // if(selectedObject)
	            // {
	            	// console.log(selectedObject.id, ' clicked');
	            // }
	            selectedObject = intersects[0].object;
	            console.log(selectedObject.userData.id, '>',selectedObject.userData.next);
	            // selectedObject.position.z = 20;
	            render();
	        }
	    }

	// controls.addEventListener( 'change', render );
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		render();

	}

	function render() {

		renderer.render( scene, camera );
		stats.update();

	}

	function rollDice()
	{
		diceValue = Math.floor(Math.random() * 6) + 1  ;
		moveCoin(diceValue);
	}


</script>