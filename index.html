<head>
	<title>All a-board</title>
	<style>
		body { margin: 0; }
		/*canvas { width: 100%; height: 100% }*/
	</style>
</head>
<body>
</body>
<script src="three.min.js"></script>

<script src="OrbitControls.js"></script>

<script src="Detector.js"></script>
<script src="stats.min.js"></script>

<script>

	if ( ! Detector.webgl ) 
		Detector.addGetWebGLMessage();

	var container, stats;

	var camera, controls, scene, renderer;

	init();
	render();

	function animate() {

		requestAnimationFrame(animate);
		controls.update();

	}

	function init() {

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = 250;

		controls = new THREE.OrbitControls( camera );
		controls.damping = 0.2;
		controls.addEventListener( 'change', render );

		scene = new THREE.Scene();
	    var axes = new THREE.AxisHelper(200);
	    scene.add(axes);
		scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

		// var geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
		// var material =  new THREE.MeshLambertMaterial( { color:0xffffff, shading: THREE.FlatShading } );

		// for ( var i = 0; i < 500; i ++ ) {

		// 	var mesh = new THREE.Mesh( geometry, material );
		// 	mesh.position.x = ( Math.random() - 0.5 ) * 1000;
		// 	mesh.position.y = ( Math.random() - 0.5 ) * 1000;
		// 	mesh.position.z = ( Math.random() - 0.5 ) * 1000;
		// 	mesh.updateMatrix();
		// 	mesh.matrixAutoUpdate = false;
		// 	scene.add( mesh );

		// }
		var tileSize = 20;
		var tileCount = 15;

		var tile = new THREE.PlaneBufferGeometry (tileSize-2, tileSize-2, 5, 5);
		// var img = new THREE.MeshBasicMaterial({ 
		 //    map:THREE.ImageUtils.loadTexture('img/woodtile.jpg')
		 //});
	    var material = new THREE.MeshPhongMaterial({
		  color: 0xdddddd, 
		  wireframe: true
		});
	    // img.map.needsUpdate = true;

	    var offset = -tileCount * tileSize/2;
	    for(var i=0;i<tileCount;i++)
	    {
	    	for(var j=0; j<tileCount; j++)
	    	{
			    if( ((i<6 || i>8) && (j>5 && j<9)  ) || ((i>5 && i<9) && (j<6 || j>8)  ) )
			    {
		    		var plane = new THREE.Mesh(tile, material);
				    // plane.overdraw = true;
				    plane.position.z = i*tileSize + offset;
				    plane.position.x = j*tileSize + offset;
				    plane.rotation.x=Math.PI/2;
				    scene.add(plane);

				    // objects.push(plane);
			    }
			}
		}

		loader = new THREE.JSONLoader();
		// loader.load('model.json', function(geo, mat){
		// 	console.log(geo,mat);
		// });

		light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( 1, 1, 1 );
		scene.add( light );

		light = new THREE.DirectionalLight( 0x002288 );
		light.position.set( -1, -1, -1 );
		scene.add( light );

		light = new THREE.AmbientLight( 0x222222 );
		scene.add( light );

		// renderer

		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setClearColor( scene.fog.color );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );

		document.body.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild( stats.domElement );

		window.addEventListener( 'resize', onWindowResize, false );

		animate();

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		render();

	}

	function render() {

		renderer.render( scene, camera );
		stats.update();

	}


</script>